name: Perpetual Dual Stream

on:
  workflow_dispatch:

jobs:
  stream:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: System Setup
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y -qq xvfb ffmpeg pulseaudio google-chrome-stable > /dev/null
          pulseaudio -D --exit-idle-time=-1 --disallow-exit || true
          pactl load-module module-null-sink sink_name=Sink1
          pactl load-module module-null-sink sink_name=Sink2

      - name: Python Setup
        run: pip install selenium pyvirtualdisplay requests

      - name: Create Python Script
        run: |
          cat << 'EOF' > main.py
          import os
          import subprocess
          import time
          import requests
          from pyvirtualdisplay import Display
          from selenium import webdriver
          from selenium.webdriver.chrome.options import Options
          from multiprocessing import Process

          # ==========================================
          # Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ­ÙƒÙ… ÙÙŠ Ø§Ù„ÙˆÙ‚Øª (Ø¨Ø§Ù„Ø¯Ù‚Ø§Ø¦Ù‚)
          # ==========================================
          ON_MINUTES = 1   # Ù…Ø¯Ø© Ø§Ù„Ø¨Ø« (ØºÙŠØ±Ù‡Ø§ Ù„Ù€ 60 Ù„Ø§Ø­Ù‚Ø§Ù‹)
          OFF_MINUTES = 1  # Ù…Ø¯Ø© Ø§Ù„ØªÙˆÙ‚Ù (ØºÙŠØ±Ù‡Ø§ Ù„Ù€ 60 Ù„Ø§Ø­Ù‚Ø§Ù‹)
          # ==========================================

          CONTROL_URL = "https://meja.do.am/asd/url2.txt"

          def get_control_data():
              try:
                  response = requests.get(f"{CONTROL_URL}?t={int(time.time())}", timeout=5)
                  if response.status_code == 200:
                      lines = [line.strip() for line in response.text.strip().split('\n') if line.strip()]
                      results = []
                      for line in lines:
                          parts = line.split()
                          if len(parts) >= 2:
                              results.append({"url": parts[0].strip(), "status": parts[1].strip()})
                      return results
              except: pass
              return None

          def get_driver_options(width, height):
              opts = Options()
              opts.add_argument('--no-sandbox')
              opts.add_argument('--disable-dev-shm-usage')
              opts.add_argument('--disable-gpu')
              opts.add_argument(f'--window-size={width},{height}')
              opts.add_argument('--autoplay-policy=no-user-gesture-required')
              opts.add_argument('--incognito')
              return opts

          def start_stream(stream_id, rtmp_key, sink_name):
              width, height = 720, 1280
              os.environ['PULSE_SINK'] = sink_name
              disp = Display(visible=0, size=(width, height), backend='xvfb')
              disp.start()
              
              env_vars = os.environ.copy()
              env_vars['DISPLAY'] = f":{disp.display}"
              
              driver = None
              ffmpeg_process = None
              
              try:
                  controls = get_control_data()
                  if not controls or len(controls) < stream_id: return
                  
                  config = controls[stream_id-1]
                  if config['status'] == "1":
                      driver = webdriver.Chrome(options=get_driver_options(width, height))
                      driver.get(config['url'])
                      time.sleep(10) # ÙˆÙ‚Øª Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…ÙˆÙ‚Ø¹
                      
                      ffmpeg_cmd = [
                          'ffmpeg', '-y', '-f', 'x11grab', '-s', f'{width}x{height}', '-i', f":{disp.display}",
                          '-f', 'pulse', '-i', f"{sink_name}.monitor",
                          '-c:v', 'libx264', '-preset', 'ultrafast', '-b:v', '3000k',
                          '-g', '60', '-c:a', 'aac', '-f', 'flv', f"rtmp://a.rtmp.youtube.com/live2/{rtmp_key}"
                      ]
                      ffmpeg_process = subprocess.Popen(ffmpeg_cmd, env=env_vars)
                      ffmpeg_process.wait() 
              finally:
                  if ffmpeg_process: ffmpeg_process.terminate()
                  if driver: driver.quit()
                  disp.stop()

          if __name__ == "__main__":
              R1, R2 = os.environ.get('R1'), os.environ.get('R2')
              
              run_seconds = ON_MINUTES * 60
              wait_seconds = OFF_MINUTES * 60

              while True:
                  print(f"ðŸš€ Ø¨Ø¯Ø¡ Ø¯ÙˆØ±Ø© Ø§Ù„ØªØ´ØºÙŠÙ„ Ù„Ù…Ø¯Ø© {ON_MINUTES} Ø¯Ù‚ÙŠÙ‚Ø©...")
                  p1 = Process(target=start_stream, args=(1, R1, "Sink1"))
                  p2 = Process(target=start_stream, args=(2, R2, "Sink2"))
                  
                  p1.start(); p2.start()
                  
                  # Ø§Ù„Ø¨Ù‚Ø§Ø¡ Ù‚ÙŠØ¯ Ø§Ù„ØªØ´ØºÙŠÙ„ Ù„Ù„Ù…Ø¯Ø© Ø§Ù„Ù…Ø­Ø¯Ø¯Ø©
                  time.sleep(run_seconds)
                  
                  print(f"ðŸ›‘ Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø¨Ø« Ø§Ù„Ø¢Ù†. Ø§Ø³ØªØ±Ø§Ø­Ø© Ù„Ù…Ø¯Ø© {OFF_MINUTES} Ø¯Ù‚ÙŠÙ‚Ø©...")
                  p1.terminate(); p2.terminate()
                  p1.join(); p2.join()
                  
                  # Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± Ù‚Ø¨Ù„ Ø§Ù„Ø¯ÙˆØ±Ø© Ø§Ù„Ù‚Ø§Ø¯Ù…Ø©
                  time.sleep(wait_seconds)
          EOF

      - name: Start Streaming
        env:
          R1: ${{ secrets.R1 }}
          R2: ${{ secrets.R2 }}
        run: python main.py
