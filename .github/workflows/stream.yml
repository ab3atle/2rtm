name: Perpetual Dual Stream

on:
  workflow_dispatch:
  # يمكنك إضافة جدولة زمنية هنا إذا أردت تشغيله تلقائياً كل فترة

jobs:
  stream:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: System Setup
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y -qq xvfb ffmpeg pulseaudio google-chrome-stable > /dev/null
          pulseaudio -D --exit-idle-time=-1 --disallow-exit || true
          pactl load-module module-null-sink sink_name=Sink1
          pactl load-module module-null-sink sink_name=Sink2

      - name: Python Setup
        run: pip install selenium pyvirtualdisplay requests

      - name: Create Python Script
        run: |
          cat << 'EOF' > main.py
          import os
          import subprocess
          import time
          import requests
          from pyvirtualdisplay import Display
          from selenium import webdriver
          from selenium.webdriver.chrome.options import Options
          from multiprocessing import Process

          # --- إعدادات الاختبار ---
          RUN_MINUTES = 1  # سيتم إغلاق الأكشن بالكامل بعد هذه الدقيقة
          
          CONTROL_URL = "https://meja.do.am/asd/url2.txt"

          def start_stream(stream_id, rtmp_key, sink_name):
              width, height = 720, 1280
              os.environ['PULSE_SINK'] = sink_name
              disp = Display(visible=0, size=(width, height), backend='xvfb')
              disp.start()
              env_vars = os.environ.copy()
              env_vars['DISPLAY'] = f":{disp.display}"
              
              try:
                  response = requests.get(f"{CONTROL_URL}?t={int(time.time())}")
                  lines = response.text.strip().split('\n')
                  config = lines[stream_id-1].split()
                  
                  if config[1] == "1":
                      opts = Options()
                      opts.add_argument('--no-sandbox')
                      opts.add_argument('--incognito')
                      driver = webdriver.Chrome(options=opts)
                      driver.get(config[0])
                      
                      ffmpeg_cmd = [
                          'ffmpeg', '-y', '-f', 'x11grab', '-s', f'{width}x{height}', '-i', f":{disp.display}",
                          '-f', 'pulse', '-i', f"{sink_name}.monitor",
                          '-c:v', 'libx264', '-preset', 'ultrafast', '-b:v', '3000k',
                          '-f', 'flv', f"rtmp://a.rtmp.youtube.com/live2/{rtmp_key}"
                      ]
                      subprocess.Popen(ffmpeg_cmd, env=env_vars)
                      
                      # انتظر الدقيقة المحددة ثم اخرج
                      time.sleep(RUN_MINUTES * 60)
                      print(f"⏰ انتهى وقت البث ({RUN_MINUTES} دقيقة). جاري الإغلاق...")
              finally:
                  # سيتم إغلاق كل شيء هنا تلقائياً عند انتهاء الدقيقة
                  pass

          if __name__ == "__main__":
              R1, R2 = os.environ.get('R1'), os.environ.get('R2')
              p1 = Process(target=start_stream, args=(1, R1, "Sink1"))
              p2 = Process(target=start_stream, args=(2, R2, "Sink2"))
              
              p1.start(); p2.start()
              
              # ننتظر العمليات تنتهي (بعد دقيقة)
              p1.join(timeout=RUN_MINUTES * 60 + 10)
              p2.join(timeout=RUN_MINUTES * 60 + 10)
              
              # إنهاء العمليات قسرياً للتأكد من قفل البث
              p1.terminate(); p2.terminate()
              print("✅ تم إنهاء الجلسة بنجاح.")
          EOF

      - name: Start Streaming
        env:
          R1: ${{ secrets.R1 }}
          R2: ${{ secrets.R2 }}
        run: python main.py
